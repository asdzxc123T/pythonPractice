
# = : 대입연산자
#       우항에 있는 것을 좌항에 넣어라

# 변수를 만든다 == RAM에 공간 만든다
# RAM : 재부팅하면 삭제
#       OS가 논리적으로 나눠서 관리
#       static
#       stack : (P)변수 저장(변수에는 데이터가 있는 주소값이)
#               밑에서부터 차곡차곡 공간 배정 - 다 같은 사이즈니까
#               프로그램 종료시 삭제
#       heap : (P)데이터 저장
#               컴퓨터가 적당한 위치에 배정 - 사이즈가 천차만별
#               사람이 직접 삭제해야 -> (P) Garbage Collection 자동삭제
#               그 자동삭제가 발동하는 시점?

# 32비트 컴퓨터는 RAM을 다 못 쓴다?
#       RAM이 크다 => 큰 번지까지
#       stack에 저장할 수 있는 게 32비트 밖에 안 되니 큰 번지를 가리키질 못함 => RAM이 커도 의미가 없음

# 컴퓨터 32bit/64bit : stack 영역 변수 사이즈
# 

# Java : 자료형 변수명 = 값;
#       데이터의 특징을 파악해서 자료형을 지정해줘야 함 -> 효율적
# Python : 변수명 = 값
#       비효율
#           자료형은 Python이 알아서 골라줌 -> 느려짐
#           사이즈를 못 고름 -> RAM 공간 낭비
#       소스 가독성 떨어짐

# 변수 : 데이터 담는 그릇
# 자료형(data type) : 그릇 종류
b = 20 # 정수
print(b)
print(type(b)) # 자료형 확인
print(id(b)) # heap 영역 주소값 확인

c = 3.14 # c라는 변수를 만들어서 3.14를 저장
print(c)
print(type(c))
print(id(c))

c = "ㅋ" # 원래 있던 c의 값을 ㅋ으로 바꾸기
print(c, type(c), id(c))